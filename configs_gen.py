import requests
import json
from collections import defaultdict
import copy
import os
import sys

# Mapping of flag emojis to country names
EMOJI_TO_COUNTRY = {
    "🇩🇪": "Germany",
    "🇳🇱": "Netherlands",
    "🇫🇮": "Finland",
    "🇺🇸": "USA",
    "🇬🇧": "UK",
    "🏴󠁧󠁢󠁥󠁮󠁧󠁿": "England",
    "🇨🇦": "Canada",
    "🇫🇷": "France",
    "🇯🇵": "Japan",
    "🇦🇺": "Australia",
    # Add more mappings as needed
    "(nm_zorp)": "Zorp",
    "🛜": "WiFi",
    "✅": "Checked",
    "❌": "Blocked"
}


def create_final_config():
    """
    Fetches V2Ray configurations, processes them, and generates a final
    'configs.json' file with a load balancer.
    The URL is fetched from a GitHub Secret.
    """
    # Get the URL from an environment variable set by GitHub Actions
    url = os.getenv('V2RAY_URL')
    if not url:
        print("Error: V2RAY_URL environment variable not set.")
        print("Please set it as a secret in your GitHub repository settings.")
        sys.exit(1) # Exit the script with an error code

    headers = {"User-Agent": "v2rayNG/1.10.7"}

    # Base template for the final JSON configuration
    main_template = {
      "log": {"loglevel": "warning"},
      "dns": {"queryStrategy": "UseIPv4", "servers": ["https://1.0.0.1/dns-query"], "tag": "dns_out"},
      "fakedns": [],
      "routing": {
        "balancers": [{"tag": "balancer", "selector": [], "strategy": {"type": "leastPing"}}],
        "domainStrategy": "IPIfNonMatch",
        "rules": [
          {"domain": ["geosite:category-ads-all"], "outboundTag": "block"},
          {"port": "53", "network": "udp", "outboundTag": "dns-out"},
          {"domain": ["regexp:.*\\.ir", "domain:.ir"], "outboundTag": "direct"},
          {"ip": ["geoip:ir", "geoip:private"], "outboundTag": "direct"},
          {"protocol": ["bittorrent"], "outboundTag": "block", "type": "field"},
          {"type": "field", "balancerTag": "balancer", "network": "tcp,udp"}
        ]
      },
      "policy": {"system": {"statsOutboundDownlink": True, "statsOutboundUplink": True}},
      "inbounds": [
        {"port": 10808, "protocol": "socks", "settings": {"auth": "noauth", "udp": True, "userLevel": 8}, "sniffing": {"destOverride": ["http", "tls"], "enabled": True}, "tag": "socks"},
        {"port": 10809, "protocol": "http", "settings": {"userLevel": 8}, "tag": "http"}
      ],
      "outbounds": [
        # Standard non-proxy outbounds
        {"tag": "direct", "protocol": "freedom", "settings": {"domainStrategy": "UseIPv4"}},
        {"tag": "block", "protocol": "blackhole"},
        {"tag": "dns-out", "protocol": "dns"}
      ],
      "observatory": {
        "subjectSelector": [],
        "probeURL": "http://www.google.com/gen_204",
        "probeInterval": "5m",
        "enableConcurrency": True
      },
       "burstObservatory": {
        "subjectSelector": [],
        "pingConfig": {
            "destination": "http://www.google.com/gen_204",
            "interval": "5m",
            "timeout": "10s",
            "sampling": 3
        }
      },
      "stats": {},
      "remarks": "Generated by F-T"
    }

    try:
        print("Fetching data from URL...")
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        data = response.json()
        print("Data fetched successfully.")

        # Group configurations by the first part of their 'remarks' (the emoji)
        grouped_data = defaultdict(list)
        for item in data:
            remarks = item.get("remarks", "")
            if remarks:
                key = remarks.split()[0]
                grouped_data[key].append(item)

        print(f"Found {len(grouped_data)} groups based on remarks.")

        processed_outbounds = []
        proxy_tags = []
        proxy_counter = 1

        # Process each group to extract the first outbound proxy
        for emoji, items in grouped_data.items():
            if not items:
                continue

            first_item_in_group = items[0]
            if "outbounds" in first_item_in_group and first_item_in_group["outbounds"]:
                # Find the first outbound with the tag 'proxy'
                original_proxy = next((ob for ob in first_item_in_group["outbounds"] if ob.get("tag") == "proxy"), None)
                
                if original_proxy:
                    # Create a deep copy to avoid modifying the original dict
                    new_proxy = copy.deepcopy(original_proxy)
                    
                    # Generate new tag and remark
                    new_tag = f"proxy{proxy_counter}"
                    country_name = EMOJI_TO_COUNTRY.get(emoji, "Unknown")
                    new_remark = f"{emoji} {country_name}"

                    # Update the proxy object
                    new_proxy["tag"] = new_tag
                    new_proxy["remarks"] = new_remark
                    
                    processed_outbounds.append(new_proxy)
                    proxy_tags.append(new_tag)
                    proxy_counter += 1

        print(f"Processed {len(processed_outbounds)} proxy configurations.")

        # Add the processed proxies to the main template's outbounds
        main_template["outbounds"] = processed_outbounds + main_template["outbounds"]

        # Update the selectors in balancer and observatory
        main_template["routing"]["balancers"][0]["selector"] = proxy_tags
        main_template["observatory"]["subjectSelector"] = proxy_tags
        main_template["burstObservatory"]["subjectSelector"] = proxy_tags
        print("Updated balancer and observatory selectors.")

        # Write the final configuration to a file
        with open("configs.json", "w", encoding="utf-8") as f:
            json.dump(main_template, f, indent=2, ensure_ascii=False)
        
        print("\nSuccessfully created 'configs.json' file.")

    except requests.exceptions.RequestException as e:
        print(f"An error occurred during the request: {e}")
    except json.JSONDecodeError as e:
        print(f"Failed to parse JSON response: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")


if __name__ == "__main__":
    create_final_config()
